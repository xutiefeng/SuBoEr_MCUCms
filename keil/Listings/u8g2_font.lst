C51 COMPILER V9.60.0.0   U8G2_FONT                                                         10/18/2024 17:39:02 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE U8G2_FONT
OBJECT MODULE PLACED IN .\Objects\u8g2_font.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\u8g2\u8g2_font.c OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Libary\Devic
                    -e\CMS8S6990\Include;..\Libary\StdDriver\inc;..\code;..\u8g2;..\GUI) DEBUG PRINT(.\Listings\u8g2_font.lst) TABS(2) OBJECT
                    -(.\Objects\u8g2_font.obj)

line level    source

   1          #include "u8g2.h"
   2          #define U8G2_FONT_DATA_STRUCT_SIZE 23
   3          
   4          ///*
   5          //  font data:
   6          
   7          //  offset  bytes description
   8          //  0   1   glyph_cnt   number of glyphs
   9          //  1   1   bbx_mode  0: proportional, 1: common height, 2: monospace, 3: multiple of 8
  10          //  2   1   bits_per_0  glyph rle parameter
  11          //  3   1   bits_per_1  glyph rle parameter
  12          
  13          //  4   1   bits_per_char_width   glyph rle parameter
  14          //  5   1   bits_per_char_height  glyph rle parameter
  15          //  6   1   bits_per_char_x   glyph rle parameter
  16          //  7   1   bits_per_char_y   glyph rle parameter
  17          //  8   1   bits_per_delta_x    glyph rle parameter
  18          
  19          //  9   1   max_char_width
  20          //  10    1   max_char_height
  21          //  11    1   x offset
  22          //  12    1   y offset (descent)
  23          //  
  24          //  13    1   ascent (capital A)
  25          //  14    1   descent (lower g)
  26          //  15    1   ascent '('
  27          //  16    1   descent ')'
  28          //  
  29          //  17    1   start pos 'A' high byte
  30          //  18    1   start pos 'A' low byte
  31          
  32          //  19    1   start pos 'a' high byte
  33          //  20    1   start pos 'a' low byte
  34          
  35          //  21    1   start pos unicode high byte
  36          //  22    1   start pos unicode low byte
  37          
  38          //  Font build mode, 0: proportional, 1: common height, 2: monospace, 3: multiple of 8
  39          
  40          //  Font build mode 0:    
  41          //    - "t"
  42          //    - Ref height mode: U8G2_FONT_HEIGHT_MODE_TEXT, U8G2_FONT_HEIGHT_MODE_XTEXT or U8G2_FONT_HEIGHT_MODE_
             -ALL
  43          //    - use in transparent mode only (does not look good in solid mode)
  44          //    - most compact format
  45          //    - different font heights possible
  46          //    
  47          //  Font build mode 1:    
  48          //    - "h"
  49          //    - Ref height mode: U8G2_FONT_HEIGHT_MODE_ALL
  50          //    - transparent or solid mode
  51          //    - The height of the glyphs depend on the largest glyph in the font. This means font height depends o
             -n postfix "r", "f" and "n".
C51 COMPILER V9.60.0.0   U8G2_FONT                                                         10/18/2024 17:39:02 PAGE 2   

  52          
  53          //*/
  54          
  55          ///* use case: What is the width and the height of the minimal box into which string s fints? */
  56          //void u8g2_font_GetStrSize(const void *font, const char *s, u8g2_uint_t *width, u8g2_uint_t *height);
  57          //void u8g2_font_GetStrSizeP(const void *font, const char *s, u8g2_uint_t *width, u8g2_uint_t *height);
  58          
  59          ///* use case: lower left edge of a minimal box is known, what is the correct x, y position for the string
             - draw procedure */
  60          //void u8g2_font_AdjustXYToDraw(const void *font, const char *s, u8g2_uint_t *x, u8g2_uint_t *y);
  61          //void u8g2_font_AdjustXYToDrawP(const void *font, const char *s, u8g2_uint_t *x, u8g2_uint_t *y);
  62          
  63          ///* use case: Baseline origin known, return minimal box */
  64          //void u8g2_font_GetStrMinBox(u8g2_t *u8g2, const void *font, const char *s, u8g2_uint_t *x, u8g2_uint_t *
             -y, u8g2_uint_t *width, u8g2_uint_t *height);
  65          
  66          ///* procedures */
  67          
  68          ///*========================================================================*/
  69          ///* low level byte and word access */
  70          
  71          ///* removed NOINLINE, because it leads to smaller code, might also be faster */
  72          ////static uint8_t u8g2_font_get_byte(const uint8_t *font, uint8_t offset) U8G2_NOINLINE;
  73          //static uint8_t u8g2_font_get_byte(const uint8_t *font, uint8_t offset)
  74          //{
  75          //  font += offset;
  76          //  return u8x8_pgm_read( font );  
  77          //}
  78          
  79          //static uint16_t u8g2_font_get_word(const uint8_t *font, uint8_t offset) U8G2_NOINLINE; 
  80          //static uint16_t u8g2_font_get_word(const uint8_t *font, uint8_t offset)
  81          //{
  82          //    uint16_t pos;
  83          //    font += offset;
  84          //    pos = u8x8_pgm_read( font );
  85          //    font++;
  86          //    pos <<= 8;
  87          //    pos += u8x8_pgm_read( font);
  88          //    return pos;
  89          //}
  90          
  91          ///*========================================================================*/
  92          ///* new font format */
  93          //void u8g2_read_font_info(u8g2_font_info_t *font_info, const uint8_t *font)
  94          //{
  95          //  /* offset 0 */
  96          //  font_info->glyph_cnt = u8g2_font_get_byte(font, 0);
  97          //  font_info->bbx_mode = u8g2_font_get_byte(font, 1);
  98          //  font_info->bits_per_0 = u8g2_font_get_byte(font, 2);
  99          //  font_info->bits_per_1 = u8g2_font_get_byte(font, 3);
 100          //  
 101          //  /* offset 4 */
 102          //  font_info->bits_per_char_width = u8g2_font_get_byte(font, 4);
 103          //  font_info->bits_per_char_height = u8g2_font_get_byte(font, 5);
 104          //  font_info->bits_per_char_x = u8g2_font_get_byte(font, 6);
 105          //  font_info->bits_per_char_y = u8g2_font_get_byte(font, 7);
 106          //  font_info->bits_per_delta_x = u8g2_font_get_byte(font, 8);
 107          //  
 108          //  /* offset 9 */
 109          //  font_info->max_char_width = u8g2_font_get_byte(font, 9);
 110          //  font_info->max_char_height = u8g2_font_get_byte(font, 10);
 111          //  font_info->x_offset = u8g2_font_get_byte(font, 11);
C51 COMPILER V9.60.0.0   U8G2_FONT                                                         10/18/2024 17:39:02 PAGE 3   

 112          //  font_info->y_offset = u8g2_font_get_byte(font, 12);
 113          //  
 114          //  /* offset 13 */
 115          //  font_info->ascent_A = u8g2_font_get_byte(font, 13);
 116          //  font_info->descent_g = u8g2_font_get_byte(font, 14);
 117          //  font_info->ascent_para = u8g2_font_get_byte(font, 15);
 118          //  font_info->descent_para = u8g2_font_get_byte(font, 16);
 119          //  
 120          //  /* offset 17 */
 121          //  font_info->start_pos_upper_A = u8g2_font_get_word(font, 17);
 122          //  font_info->start_pos_lower_a = u8g2_font_get_word(font, 19); 
 123          //  
 124          //  /* offset 21 */
 125          //#ifdef U8G2_WITH_UNICODE
 126          //  font_info->start_pos_unicode = u8g2_font_get_word(font, 21); 
 127          //#endif
 128          //}
 129          
 130          
 131          ///* calculate the overall length of the font, only used to create the picture for the google wiki */
 132          //size_t u8g2_GetFontSize(const uint8_t *font_arg)
 133          //{
 134          //  uint16_t e;
 135          //  const uint8_t *font = font_arg;
 136          //  font += U8G2_FONT_DATA_STRUCT_SIZE;
 137          //  
 138          //  for(;;)
 139          //  {
 140          //    if ( u8x8_pgm_read( font + 1 ) == 0 )
 141          //      break;
 142          //    font += u8x8_pgm_read( font + 1 );
 143          //  }
 144          //  
 145          //  /* continue with unicode section */
 146          //  font += 2;
 147          
 148          //  /* skip unicode lookup table */
 149          //  font += u8g2_font_get_word(font, 0);
 150          //  
 151          //  for(;;)
 152          //  {
 153          //    e = u8x8_pgm_read( font );
 154          //    e <<= 8;
 155          //    e |= u8x8_pgm_read( font + 1 );
 156          //    if ( e == 0 )
 157          //      break;
 158          //    font += u8x8_pgm_read( font + 2 );    
 159          //  }
 160          //  
 161          //  return (font - font_arg) + 2;
 162          //}
 163          
 164          ///*========================================================================*/
 165          ///* u8g2 interface, font access */
 166          
 167          //uint8_t u8g2_GetFontBBXWidth(u8g2_t *u8g2)
 168          //{
 169          //  return u8g2->font_info.max_char_width;    /* new font info structure */
 170          //}
 171          
 172          //uint8_t u8g2_GetFontBBXHeight(u8g2_t *u8g2)
 173          //{
C51 COMPILER V9.60.0.0   U8G2_FONT                                                         10/18/2024 17:39:02 PAGE 4   

 174          //  return u8g2->font_info.max_char_height;   /* new font info structure */
 175          //}
 176          
 177          //int8_t u8g2_GetFontBBXOffX(u8g2_t *u8g2) U8G2_NOINLINE;
 178          //int8_t u8g2_GetFontBBXOffX(u8g2_t *u8g2)
 179          //{
 180          //  return u8g2->font_info.x_offset;    /* new font info structure */
 181          //}
 182          
 183          //int8_t u8g2_GetFontBBXOffY(u8g2_t *u8g2) U8G2_NOINLINE;
 184          //int8_t u8g2_GetFontBBXOffY(u8g2_t *u8g2)
 185          //{
 186          //  return u8g2->font_info.y_offset;    /* new font info structure */
 187          //}
 188          
 189          //uint8_t u8g2_GetFontCapitalAHeight(u8g2_t *u8g2) U8G2_NOINLINE; 
 190          //uint8_t u8g2_GetFontCapitalAHeight(u8g2_t *u8g2)
 191          //{
 192          //  return u8g2->font_info.ascent_A;    /* new font info structure */
 193          //}
 194          
 195          ///*========================================================================*/
 196          ///* glyph handling */
 197          
 198          ///* optimized */
 199          //uint8_t u8g2_font_decode_get_unsigned_bits(u8g2_font_decode_t *f, uint8_t cnt) 
 200          //{
 201          //  uint8_t val;
 202          //  uint8_t bit_pos = f->decode_bit_pos;
 203          //  uint8_t bit_pos_plus_cnt;
 204          //  
 205          //  //val = *(f->decode_ptr);
 206          //  val = u8x8_pgm_read( f->decode_ptr );  
 207          //  
 208          //  val >>= bit_pos;
 209          //  bit_pos_plus_cnt = bit_pos;
 210          //  bit_pos_plus_cnt += cnt;
 211          //  if ( bit_pos_plus_cnt >= 8 )
 212          //  {
 213          //    uint8_t s = 8;
 214          //    s -= bit_pos;
 215          //    f->decode_ptr++;
 216          //    //val |= *(f->decode_ptr) << (8-bit_pos);
 217          //    val |= u8x8_pgm_read( f->decode_ptr ) << (s);
 218          //    //bit_pos -= 8;
 219          //    bit_pos_plus_cnt -= 8;
 220          //  }
 221          //  val &= (1U<<cnt)-1;
 222          //  //bit_pos += cnt;
 223          //  
 224          //  f->decode_bit_pos = bit_pos_plus_cnt;
 225          //  return val;
 226          //}
 227          
 228          
 229          ///*
 230          //    2 bit --> cnt = 2
 231          //      -2,-1,0. 1
 232          
 233          //    3 bit --> cnt = 3
 234          //      -2,-1,0. 1
 235          //      -4,-3,-2,-1,0,1,2,3
C51 COMPILER V9.60.0.0   U8G2_FONT                                                         10/18/2024 17:39:02 PAGE 5   

 236          
 237          //      if ( x < 0 )
 238          //  r = bits(x-1)+1;
 239          //    else
 240          //  r = bits(x)+1;
 241          
 242          //*/
 243          ///* optimized */
 244          //int8_t u8g2_font_decode_get_signed_bits(u8g2_font_decode_t *f, uint8_t cnt)
 245          //{
 246          //  int8_t v, d;
 247          //  v = (int8_t)u8g2_font_decode_get_unsigned_bits(f, cnt);
 248          //  d = 1;
 249          //  cnt--;
 250          //  d <<= cnt;
 251          //  v -= d;
 252          //  return v;
 253          //  //return (int8_t)u8g2_font_decode_get_unsigned_bits(f, cnt) - ((1<<cnt)>>1);
 254          //}
 255          
 256          
 257          //#ifdef U8G2_WITH_FONT_ROTATION
 258          //u8g2_uint_t u8g2_add_vector_y(u8g2_uint_t dy, int8_t x, int8_t y, uint8_t dir)
 259          //{
 260          //  switch(dir)
 261          //  {
 262          //    case 0:
 263          //      dy += y;
 264          //      break;
 265          //    case 1:
 266          //      dy += x;
 267          //      break;
 268          //    case 2:
 269          //      dy -= y;
 270          //      break;
 271          //    default:
 272          //      dy -= x;
 273          //      break;      
 274          //  }
 275          //  return dy;
 276          //}
 277          
 278          //u8g2_uint_t u8g2_add_vector_x(u8g2_uint_t dx, int8_t x, int8_t y, uint8_t dir)
 279          //{
 280          //  switch(dir)
 281          //  {
 282          //    case 0:
 283          //      dx += x;
 284          //      break;
 285          //    case 1:
 286          //      dx -= y;
 287          //      break;
 288          //    case 2:
 289          //      dx -= x;
 290          //      break;
 291          //    default:
 292          //      dx += y;
 293          //      break;      
 294          //  }
 295          //  return dx;
 296          //}
 297          
C51 COMPILER V9.60.0.0   U8G2_FONT                                                         10/18/2024 17:39:02 PAGE 6   

 298          ///*
 299          //// does not make sense, 50 bytes more required on avr
 300          //void u8g2_add_vector(u8g2_uint_t *xp, u8g2_uint_t *yp, int8_t x, int8_t y, uint8_t dir)
 301          //{
 302          //  u8g2_uint_t x_ = *xp;
 303          //  u8g2_uint_t y_ = *yp;
 304          //  switch(dir)
 305          //  {
 306          //    case 0:
 307          //      y_ += y;
 308          //      x_ += x;
 309          //      break;
 310          //    case 1:
 311          //      y_ += x;
 312          //      x_ -= y;
 313          //      break;
 314          //    case 2:
 315          //      y_ -= y;
 316          //      x_ -= x;
 317          //      break;
 318          //    default:
 319          //      y_ -= x;
 320          //      x_ += y;
 321          //      break;      
 322          //  }
 323          //  *xp = x_;
 324          //  *yp = y_;
 325          //}
 326          //*/
 327          //#endif
 328          
 329          
 330          
 331          ///*
 332          //  Description:
 333          //    Draw a run-length area of the glyph. "len" can have any size and the line
 334          //    length has to be wrapped at the glyph border.
 335          //  Args:
 336          //    len:          Length of the line
 337          //    is_foreground     foreground/background?
 338          //    u8g2->font_decode.target_x    X position
 339          //    u8g2->font_decode.target_y    Y position
 340          //    u8g2->font_decode.is_transparent  Transparent mode
 341          //  Return:
 342          //    -
 343          //  Calls:
 344          //    u8g2_Draw90Line()
 345          //  Called by:
 346          //    u8g2_font_decode_glyph()
 347          //*/
 348          ///* optimized */
 349          //void u8g2_font_decode_len(u8g2_t *u8g2, uint8_t len, uint8_t is_foreground)
 350          //{
 351          //  uint8_t cnt;  /* total number of remaining pixels, which have to be drawn */
 352          //  uint8_t rem;  /* remaining pixel to the right edge of the glyph */
 353          //  uint8_t current;  /* number of pixels, which need to be drawn for the draw procedure */
 354          //    /* current is either equal to cnt or equal to rem */
 355          //  
 356          //  /* local coordinates of the glyph */
 357          //  uint8_t lx,ly;
 358          //  
 359          //  /* target position on the screen */
C51 COMPILER V9.60.0.0   U8G2_FONT                                                         10/18/2024 17:39:02 PAGE 7   

 360          //  u8g2_uint_t x, y;
 361          //  
 362          //  u8g2_font_decode_t *decode = &(u8g2->font_decode);
 363          //  
 364          //  cnt = len;
 365          //  
 366          //  /* get the local position */
 367          //  lx = decode->x;
 368          //  ly = decode->y;
 369          //  
 370          //  for(;;)
 371          //  {
 372          //    /* calculate the number of pixel to the right edge of the glyph */
 373          //    rem = decode->glyph_width;
 374          //    rem -= lx;
 375          //    
 376          //    /* calculate how many pixel to draw. This is either to the right edge */
 377          //    /* or lesser, if not enough pixel are left */
 378          //    current = rem;
 379          //    if ( cnt < rem )
 380          //      current = cnt;
 381          //    
 382          //    
 383          //    /* now draw the line, but apply the rotation around the glyph target position */
 384          //    //u8g2_font_decode_draw_pixel(u8g2, lx,ly,current, is_foreground);
 385          
 386          //    /* get target position */
 387          //    x = decode->target_x;
 388          //    y = decode->target_y;
 389          
 390          //    /* apply rotation */
 391          //#ifdef U8G2_WITH_FONT_ROTATION
 392          //    
 393          //    x = u8g2_add_vector_x(x, lx, ly, decode->dir);
 394          //    y = u8g2_add_vector_y(y, lx, ly, decode->dir);
 395          //    
 396          //    //u8g2_add_vector(&x, &y, lx, ly, decode->dir);
 397          //    
 398          //#else
 399          //    x += lx;
 400          //    y += ly;
 401          //#endif
 402          //    
 403          //    /* draw foreground and background (if required) */
 404          //    if ( is_foreground )
 405          //    {
 406          //      u8g2->draw_color = decode->fg_color;      /* draw_color will be restored later */
 407          //      u8g2_DrawHVLine(u8g2, 
 408          //  x, 
 409          //  y, 
 410          //  current, 
 411          //#ifdef U8G2_WITH_FONT_ROTATION
 412          //  /* dir */ decode->dir
 413          //#else
 414          //  0
 415          //#endif
 416          //      );
 417          //    }
 418          //    else if ( decode->is_transparent == 0 )    
 419          //    {
 420          //      u8g2->draw_color = decode->bg_color;      /* draw_color will be restored later */
 421          //      u8g2_DrawHVLine(u8g2, 
C51 COMPILER V9.60.0.0   U8G2_FONT                                                         10/18/2024 17:39:02 PAGE 8   

 422          //  x, 
 423          //  y, 
 424          //  current, 
 425          //#ifdef U8G2_WITH_FONT_ROTATION
 426          //  /* dir */ decode->dir
 427          //#else
 428          //  0
 429          //#endif
 430          //      );   
 431          //    }
 432          //    
 433          //    /* check, whether the end of the run length code has been reached */
 434          //    if ( cnt < rem )
 435          //      break;
 436          //    cnt -= rem;
 437          //    lx = 0;
 438          //    ly++;
 439          //  }
 440          //  lx += cnt;
 441          //  
 442          //  decode->x = lx;
 443          //  decode->y = ly;
 444          //  
 445          //}
 446          
 447          //static void u8g2_font_setup_decode(u8g2_t *u8g2, const uint8_t *glyph_data)
 448          //{
 449          //  u8g2_font_decode_t *decode = &(u8g2->font_decode);
 450          //  decode->decode_ptr = glyph_data;
 451          //  decode->decode_bit_pos = 0;
 452          //  
 453          //  /* 8 Nov 2015, this is already done in the glyph data search procedure */
 454          //  /*
 455          //  decode->decode_ptr += 1;
 456          //  decode->decode_ptr += 1;
 457          //  */
 458          //  
 459          //  decode->glyph_width = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_char_width);
 460          //  decode->glyph_height = u8g2_font_decode_get_unsigned_bits(decode,u8g2->font_info.bits_per_char_height)
             -;
 461          //  
 462          //  decode->fg_color = u8g2->draw_color;
 463          //  decode->bg_color = (decode->fg_color == 0 ? 1 : 0);
 464          //}
 465          
 466          
 467          ///*
 468          //  Description:
 469          //    Decode and draw a glyph.
 470          //  Args:
 471          //    glyph_data:           Pointer to the compressed glyph data of the font
 472          //    u8g2->font_decode.target_x    X position
 473          //    u8g2->font_decode.target_y    Y position
 474          //    u8g2->font_decode.is_transparent  Transparent mode
 475          //  Return:
 476          //    Width (delta x advance) of the glyph.
 477          //  Calls:
 478          //    u8g2_font_decode_len()
 479          //*/
 480          ///* optimized */
 481          //int8_t u8g2_font_decode_glyph(u8g2_t *u8g2, const uint8_t *glyph_data)
 482          //{
C51 COMPILER V9.60.0.0   U8G2_FONT                                                         10/18/2024 17:39:02 PAGE 9   

 483          //  uint8_t a, b;
 484          //  int8_t x, y;
 485          //  int8_t d;
 486          //  int8_t h;
 487          //  u8g2_font_decode_t *decode = &(u8g2->font_decode);
 488          //    
 489          //  u8g2_font_setup_decode(u8g2, glyph_data);     /* set values in u8g2->font_decode data structure */
 490          //  h = u8g2->font_decode.glyph_height;
 491          //  
 492          //  x = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_char_x);
 493          //  y = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_char_y);
 494          //  d = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_delta_x);
 495          //  
 496          //  if ( decode->glyph_width > 0 )
 497          //  {
 498          //#ifdef U8G2_WITH_FONT_ROTATION
 499          //    decode->target_x = u8g2_add_vector_x(decode->target_x, x, -(h+y), decode->dir);
 500          //    decode->target_y = u8g2_add_vector_y(decode->target_y, x, -(h+y), decode->dir);
 501          //    
 502          //    //u8g2_add_vector(&(decode->target_x), &(decode->target_y), x, -(h+y), decode->dir);
 503          
 504          //#else
 505          //    decode->target_x += x;
 506          //    decode->target_y -= h+y;
 507          //#endif
 508          //    //u8g2_add_vector(&(decode->target_x), &(decode->target_y), x, -(h+y), decode->dir);
 509          
 510          //#ifdef U8G2_WITH_INTERSECTION
 511          //    {
 512          //      u8g2_uint_t x0, x1, y0, y1;
 513          //      x0 = decode->target_x;
 514          //      y0 = decode->target_y;
 515          //      x1 = x0;
 516          //      y1 = y0;
 517          //      
 518          //#ifdef U8G2_WITH_FONT_ROTATION
 519          //      switch(decode->dir)
 520          //      {
 521          //  case 0:
 522          //      x1 += decode->glyph_width;
 523          //      y1 += h;
 524          //      break;
 525          //  case 1:
 526          //      x0 -= h;
 527          //      x0++; /* shift down, because of assymetric boundaries for the interseciton test */
 528          //      x1++;
 529          //      y1 += decode->glyph_width;
 530          //      break;
 531          //  case 2:
 532          //      x0 -= decode->glyph_width;
 533          //      x0++; /* shift down, because of assymetric boundaries for the interseciton test */
 534          //      x1++;
 535          //      y0 -= h;
 536          //      y0++; /* shift down, because of assymetric boundaries for the interseciton test */
 537          //      y1++;
 538          //      break;    
 539          //  case 3:
 540          //      x1 += h;
 541          //      y0 -= decode->glyph_width;
 542          //      y0++; /* shift down, because of assymetric boundaries for the interseciton test */
 543          //      y1++;
 544          //      break;    
C51 COMPILER V9.60.0.0   U8G2_FONT                                                         10/18/2024 17:39:02 PAGE 10  

 545          //      }
 546          //#else /* U8G2_WITH_FONT_ROTATION */
 547          //      x1 += decode->glyph_width;
 548          //      y1 += h;      
 549          //#endif
 550          //      
 551          //      if ( u8g2_IsIntersection(u8g2, x0, y0, x1, y1) == 0 ) 
 552          //  return d;
 553          //    }
 554          //#endif /* U8G2_WITH_INTERSECTION */
 555          //   
 556          //    /* reset local x/y position */
 557          //    decode->x = 0;
 558          //    decode->y = 0;
 559          //    
 560          //    /* decode glyph */
 561          //    for(;;)
 562          //    {
 563          //      a = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_0);
 564          //      b = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_1);
 565          //      do
 566          //      {
 567          //  u8g2_font_decode_len(u8g2, a, 0);
 568          //  u8g2_font_decode_len(u8g2, b, 1);
 569          //      } while( u8g2_font_decode_get_unsigned_bits(decode, 1) != 0 );
 570          
 571          //      if ( decode->y >= h )
 572          //  break;
 573          //    }
 574          //    
 575          //    /* restore the u8g2 draw color, because this is modified by the decode algo */
 576          //    u8g2->draw_color = decode->fg_color;
 577          //  }
 578          //  return d;
 579          //}
 580          
 581          ///*
 582          //  Description:
 583          //    Find the starting point of the glyph data.
 584          //  Args:
 585          //    encoding: Encoding (ASCII or Unicode) of the glyph
 586          //  Return:
 587          //    Address of the glyph data or NULL, if the encoding is not avialable in the font.
 588          //*/
 589          //const uint8_t *u8g2_font_get_glyph_data(u8g2_t *u8g2, uint16_t encoding)
 590          //{
 591          //  const uint8_t *font = u8g2->font;
 592          //  font += U8G2_FONT_DATA_STRUCT_SIZE;
 593          
 594          //  
 595          //  if ( encoding <= 255 )
 596          //  {
 597          //    if ( encoding >= 'a' )
 598          //    {
 599          //      font += u8g2->font_info.start_pos_lower_a;
 600          //    }
 601          //    else if ( encoding >= 'A' )
 602          //    {
 603          //      font += u8g2->font_info.start_pos_upper_A;
 604          //    }
 605          //    
 606          //    for(;;)
C51 COMPILER V9.60.0.0   U8G2_FONT                                                         10/18/2024 17:39:02 PAGE 11  

 607          //    {
 608          //      if ( u8x8_pgm_read( font + 1 ) == 0 )
 609          //  break;
 610          //      if ( u8x8_pgm_read( font ) == encoding )
 611          //      {
 612          //  return font+2;  /* skip encoding and glyph size */
 613          //      }
 614          //      font += u8x8_pgm_read( font + 1 );
 615          //    }
 616          //  }
 617          //#ifdef U8G2_WITH_UNICODE
 618          //  else
 619          //  {
 620          //    uint16_t e;
 621          //    const uint8_t *unicode_lookup_table;
 622          //    
 623          //// removed, there is now the new index table
 624          ////#ifdef  __unix__
 625          ////    if ( u8g2->last_font_data != NULL && encoding >= u8g2->last_unicode )
 626          ////    {
 627          ////  font = u8g2->last_font_data;
 628          ////    }
 629          ////    else
 630          ////#endif 
 631          
 632          //    font += u8g2->font_info.start_pos_unicode;
 633          //    unicode_lookup_table = font; 
 634          //  
 635          //    /* issue 596: search for the glyph start in the unicode lookup table */
 636          //    do
 637          //    {
 638          //      font += u8g2_font_get_word(unicode_lookup_table, 0);
 639          //      e = u8g2_font_get_word(unicode_lookup_table, 2);
 640          //      unicode_lookup_table+=4;
 641          //    } while( e < encoding );
 642          //    
 643          //  
 644          //    for(;;)
 645          //    {
 646          //      e = u8x8_pgm_read( font );
 647          //      e <<= 8;
 648          //      e |= u8x8_pgm_read( font + 1 );
 649          //  
 650          //// removed, there is now the new index table  
 651          ////#ifdef  __unix__
 652          ////      if ( encoding < e )
 653          ////        break;
 654          ////#endif 
 655          
 656          //      if ( e == 0 )
 657          //  break;
 658          //  
 659          //      if ( e == encoding )
 660          //      {
 661          //// removed, there is now the new index table
 662          ////#ifdef  __unix__
 663          ////  u8g2->last_font_data = font;
 664          ////  u8g2->last_unicode = encoding;
 665          ////#endif 
 666          //  return font+3;  /* skip encoding and glyph size */
 667          //      }
 668          //      font += u8x8_pgm_read( font + 2 );
C51 COMPILER V9.60.0.0   U8G2_FONT                                                         10/18/2024 17:39:02 PAGE 12  

 669          //    }  
 670          //  }
 671          //#endif
 672          //  
 673          //  return NULL;
 674          //}
 675          
 676          //static u8g2_uint_t u8g2_font_draw_glyph(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, uint16_t encoding)
 677          //{
 678          //  u8g2_uint_t dx = 0;
 679          //  u8g2->font_decode.target_x = x;
 680          //  u8g2->font_decode.target_y = y;
 681          //  //u8g2->font_decode.is_transparent = is_transparent; this is already set
 682          //  //u8g2->font_decode.dir = dir;
 683          //  const uint8_t *glyph_data = u8g2_font_get_glyph_data(u8g2, encoding);
 684          //  if ( glyph_data != NULL )
 685          //  {
 686          //    dx = u8g2_font_decode_glyph(u8g2, glyph_data);
 687          //  }
 688          //  return dx;
 689          //}
 690          
 691          
 692          
 693          //uint8_t u8g2_IsGlyph(u8g2_t *u8g2, uint16_t requested_encoding)
 694          //{
 695          //  /* updated to new code */
 696          //  if ( u8g2_font_get_glyph_data(u8g2, requested_encoding) != NULL )
 697          //    return 1;
 698          //  return 0;
 699          //}
 700          
 701          ///* side effect: updates u8g2->font_decode and u8g2->glyph_x_offset */
 702          //int8_t u8g2_GetGlyphWidth(u8g2_t *u8g2, uint16_t requested_encoding)
 703          //{
 704          //  const uint8_t *glyph_data = u8g2_font_get_glyph_data(u8g2, requested_encoding);
 705          //  if ( glyph_data == NULL )
 706          //    return 0; 
 707          //  
 708          //  u8g2_font_setup_decode(u8g2, glyph_data);
 709          //  u8g2->glyph_x_offset = u8g2_font_decode_get_signed_bits(&(u8g2->font_decode), u8g2->font_info.bits_per
             -_char_x);
 710          //  u8g2_font_decode_get_signed_bits(&(u8g2->font_decode), u8g2->font_info.bits_per_char_y);
 711          //  
 712          //  /* glyph width is here: u8g2->font_decode.glyph_width */
 713          
 714          //  return u8g2_font_decode_get_signed_bits(&(u8g2->font_decode), u8g2->font_info.bits_per_delta_x);
 715          //}
 716          
 717          
 718          ///*
 719          //  set one of:
 720          //    U8G2_FONT_MODE_TRANSPARENT
 721          //    U8G2_FONT_MODE_SOLID
 722          //    U8G2_FONT_MODE_NONE
 723          //  This has been changed for the new font procedures  
 724          //*/
 725          //void u8g2_SetFontMode(u8g2_t *u8g2, uint8_t is_transparent)
 726          //{
 727          //  u8g2->font_decode.is_transparent = is_transparent;    // new font procedures
 728          //}
 729          
C51 COMPILER V9.60.0.0   U8G2_FONT                                                         10/18/2024 17:39:02 PAGE 13  

 730          //u8g2_uint_t u8g2_DrawGlyph(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, uint16_t encoding)
 731          //{
 732          //#ifdef U8G2_WITH_FONT_ROTATION
 733          //  switch(u8g2->font_decode.dir)
 734          //  {
 735          //    case 0:
 736          //      y += u8g2->font_calc_vref(u8g2);
 737          //      break;
 738          //    case 1:
 739          //      x -= u8g2->font_calc_vref(u8g2);
 740          //      break;
 741          //    case 2:
 742          //      y -= u8g2->font_calc_vref(u8g2);
 743          //      break;
 744          //    case 3:
 745          //      x += u8g2->font_calc_vref(u8g2);
 746          //      break;
 747          //  }
 748          //#else
 749          //  y += u8g2->font_calc_vref(u8g2);
 750          //#endif
 751          //  return u8g2_font_draw_glyph(u8g2, x, y, encoding);
 752          //}
 753          
 754          //static u8g2_uint_t u8g2_draw_string(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, const char *str) U8G2_NO
             -INLINE;
 755          //static u8g2_uint_t u8g2_draw_string(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, const char *str)
 756          //{
 757          //  uint16_t e;
 758          //  u8g2_uint_t delta, sum;
 759          //  u8x8_utf8_init(u8g2_GetU8x8(u8g2));
 760          //  sum = 0;
 761          //  for(;;)
 762          //  {
 763          //    e = u8g2->u8x8.next_cb(u8g2_GetU8x8(u8g2), (uint8_t)*str);
 764          //    if ( e == 0x0ffff )
 765          //      break;
 766          //    str++;
 767          //    if ( e != 0x0fffe )
 768          //    {
 769          //      delta = u8g2_DrawGlyph(u8g2, x, y, e);
 770          //    
 771          //#ifdef U8G2_WITH_FONT_ROTATION
 772          //      switch(u8g2->font_decode.dir)
 773          //      {
 774          //  case 0:
 775          //    x += delta;
 776          //    break;
 777          //  case 1:
 778          //    y += delta;
 779          //    break;
 780          //  case 2:
 781          //    x -= delta;
 782          //    break;
 783          //  case 3:
 784          //    y -= delta;
 785          //    break;
 786          //      }
 787          //      
 788          //      /*
 789          //      // requires 10 bytes more on avr
 790          //      x = u8g2_add_vector_x(x, delta, 0, u8g2->font_decode.dir);
C51 COMPILER V9.60.0.0   U8G2_FONT                                                         10/18/2024 17:39:02 PAGE 14  

 791          //      y = u8g2_add_vector_y(y, delta, 0, u8g2->font_decode.dir);
 792          //      */
 793          
 794          //#else
 795          //      x += delta;
 796          //#endif
 797          
 798          //      sum += delta;    
 799          //    }
 800          //  }
 801          //  return sum;
 802          //}
 803          
 804          //u8g2_uint_t u8g2_DrawStr(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, const char *str)
 805          //{
 806          //  u8g2->u8x8.next_cb = u8x8_ascii_next;
 807          //  return u8g2_draw_string(u8g2, x, y, str);
 808          //}
 809          
 810          ///*
 811          //source: https://en.wikipedia.org/wiki/UTF-8
 812          //Bits  from    to      bytes Byte 1    Byte 2    Byte 3    Byte 4    Byte 5    Byte 6
 813          //  7   U+0000    U+007F    1     0xxxxxxx
 814          //11  U+0080    U+07FF    2     110xxxxx  10xxxxxx
 815          //16  U+0800    U+FFFF    3     1110xxxx  10xxxxxx  10xxxxxx
 816          //21  U+10000   U+1FFFFF  4     11110xxx  10xxxxxx  10xxxxxx  10xxxxxx
 817          //26  U+200000  U+3FFFFFF   5     111110xx  10xxxxxx  10xxxxxx  10xxxxxx  10xxxxxx
 818          //31  U+4000000   U+7FFFFFFF  6     1111110x  10xxxxxx  10xxxxxx  10xxxxxx  10xxxxxx  10xxxxxx  
 819          //*/
 820          //u8g2_uint_t u8g2_DrawUTF8(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, const char *str)
 821          //{
 822          //  u8g2->u8x8.next_cb = u8x8_utf8_next;
 823          //  return u8g2_draw_string(u8g2, x, y, str);
 824          //}
 825          
 826          
 827          
 828          //u8g2_uint_t u8g2_DrawExtendedUTF8(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, uint8_t to_left, u8g2_kern
             -ing_t *kerning, const char *str)
 829          //{
 830          //  u8g2->u8x8.next_cb = u8x8_utf8_next;
 831          //  uint16_t e_prev = 0x0ffff;
 832          //  uint16_t e;
 833          //  u8g2_uint_t delta, sum, k;
 834          //  u8x8_utf8_init(u8g2_GetU8x8(u8g2));
 835          //  sum = 0;
 836          //  for(;;)
 837          //  {
 838          //    e = u8g2->u8x8.next_cb(u8g2_GetU8x8(u8g2), (uint8_t)*str);
 839          //    if ( e == 0x0ffff )
 840          //      break;
 841          //    str++;
 842          //    if ( e != 0x0fffe )
 843          //    {
 844          //      delta = u8g2_GetGlyphWidth(u8g2, e);
 845          //      
 846          //      if ( to_left )
 847          //      {
 848          //        k = u8g2_GetKerning(u8g2, kerning, e, e_prev);
 849          //  delta -= k;
 850          //  x -= delta;
 851          //      }
C51 COMPILER V9.60.0.0   U8G2_FONT                                                         10/18/2024 17:39:02 PAGE 15  

 852          //      else
 853          //      {
 854          //        k = u8g2_GetKerning(u8g2, kerning, e_prev, e);
 855          //  delta -= k;
 856          //      }
 857          //      e_prev = e;
 858          
 859          //      u8g2_DrawGlyph(u8g2, x, y, e);
 860          //      if ( to_left )
 861          //      {
 862          //      }
 863          //      else
 864          //      {
 865          //  x += delta;
 866          //  x -= k;
 867          //      }
 868          //      
 869          //      sum += delta;    
 870          //    }
 871          //  }
 872          //  return sum;
 873          //}
 874          
 875          //u8g2_uint_t u8g2_DrawExtUTF8(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, uint8_t to_left, const uint16_t
             - *kerning_table, const char *str)
 876          //{
 877          //  u8g2->u8x8.next_cb = u8x8_utf8_next;
 878          //  uint16_t e_prev = 0x0ffff;
 879          //  uint16_t e;
 880          //  u8g2_uint_t delta, sum, k;
 881          //  u8x8_utf8_init(u8g2_GetU8x8(u8g2));
 882          //  sum = 0;
 883          //  for(;;)
 884          //  {
 885          //    e = u8g2->u8x8.next_cb(u8g2_GetU8x8(u8g2), (uint8_t)*str);
 886          //    if ( e == 0x0ffff )
 887          //      break;
 888          //    str++;
 889          //    if ( e != 0x0fffe )
 890          //    {
 891          //      delta = u8g2_GetGlyphWidth(u8g2, e);
 892          //      
 893          //      if ( to_left )
 894          //      {
 895          //        k = u8g2_GetKerningByTable(u8g2, kerning_table, e, e_prev);
 896          //  delta -= k;
 897          //  x -= delta;
 898          //      }
 899          //      else
 900          //      {
 901          //        k = u8g2_GetKerningByTable(u8g2, kerning_table, e_prev, e);
 902          //  delta -= k;
 903          //      }
 904          //      e_prev = e;
 905          
 906          //      if ( to_left )
 907          //      {
 908          //      }
 909          //      else
 910          //      {
 911          //  x += delta;
 912          //      }
C51 COMPILER V9.60.0.0   U8G2_FONT                                                         10/18/2024 17:39:02 PAGE 16  

 913          //      u8g2_DrawGlyph(u8g2, x, y, e);
 914          //      if ( to_left )
 915          //      {
 916          //      }
 917          //      else
 918          //      {
 919          //  //x += delta;
 920          //  //x -= k;
 921          //      }
 922          //      
 923          //      sum += delta;    
 924          //    }
 925          //  }
 926          //  return sum;
 927          //}
 928          
 929          
 930          
 931          ///*===============================================*/
 932          
 933          ///* set ascent/descent for reference point calculation */
 934          
 935          //void u8g2_UpdateRefHeight(u8g2_t *u8g2)
 936          //{
 937          //  if ( u8g2->font == NULL )
 938          //    return;
 939          //  u8g2->font_ref_ascent = u8g2->font_info.ascent_A;
 940          //  u8g2->font_ref_descent = u8g2->font_info.descent_g;
 941          //  if ( u8g2->font_height_mode == U8G2_FONT_HEIGHT_MODE_TEXT )
 942          //  {
 943          //  }
 944          //  else if ( u8g2->font_height_mode == U8G2_FONT_HEIGHT_MODE_XTEXT )
 945          //  {
 946          //    if ( u8g2->font_ref_ascent < u8g2->font_info.ascent_para )
 947          //      u8g2->font_ref_ascent = u8g2->font_info.ascent_para;
 948          //    if ( u8g2->font_ref_descent > u8g2->font_info.descent_para )
 949          //      u8g2->font_ref_descent = u8g2->font_info.descent_para;
 950          //  }
 951          //  else
 952          //  {
 953          //    if ( u8g2->font_ref_ascent < u8g2->font_info.max_char_height+u8g2->font_info.y_offset )
 954          //      u8g2->font_ref_ascent = u8g2->font_info.max_char_height+u8g2->font_info.y_offset;
 955          //    if ( u8g2->font_ref_descent > u8g2->font_info.y_offset )
 956          //      u8g2->font_ref_descent = u8g2->font_info.y_offset;
 957          //  }  
 958          //}
 959          
 960          //void u8g2_SetFontRefHeightText(u8g2_t *u8g2)
 961          //{
 962          //  u8g2->font_height_mode = U8G2_FONT_HEIGHT_MODE_TEXT;
 963          //  u8g2_UpdateRefHeight(u8g2);
 964          //}
 965          
 966          //void u8g2_SetFontRefHeightExtendedText(u8g2_t *u8g2)
 967          //{
 968          //  u8g2->font_height_mode = U8G2_FONT_HEIGHT_MODE_XTEXT;
 969          //  u8g2_UpdateRefHeight(u8g2);
 970          //}
 971          
 972          //void u8g2_SetFontRefHeightAll(u8g2_t *u8g2)
 973          //{
 974          //  u8g2->font_height_mode = U8G2_FONT_HEIGHT_MODE_ALL;
C51 COMPILER V9.60.0.0   U8G2_FONT                                                         10/18/2024 17:39:02 PAGE 17  

 975          //  u8g2_UpdateRefHeight(u8g2);
 976          //}
 977          
 978          ///*===============================================*/
 979          ///* callback procedures to correct the y position */
 980          
 981          //u8g2_uint_t u8g2_font_calc_vref_font(U8X8_UNUSED u8g2_t *u8g2)
 982          //{
 983          //  return 0;
 984          //}
 985          
 986          //void u8g2_SetFontPosBaseline(u8g2_t *u8g2)
 987          //{
 988          //  u8g2->font_calc_vref = u8g2_font_calc_vref_font;
 989          //}
 990          
 991          
 992          //u8g2_uint_t u8g2_font_calc_vref_bottom(u8g2_t *u8g2)
 993          //{
 994          //  return (u8g2_uint_t)(u8g2->font_ref_descent);
 995          //}
 996          
 997          //void u8g2_SetFontPosBottom(u8g2_t *u8g2)
 998          //{
 999          //  u8g2->font_calc_vref = u8g2_font_calc_vref_bottom;
1000          //}
1001          
1002          //u8g2_uint_t u8g2_font_calc_vref_top(u8g2_t *u8g2)
1003          //{
1004          //  u8g2_uint_t tmp;
1005          //  /* reference pos is one pixel above the upper edge of the reference glyph */
1006          //  tmp = (u8g2_uint_t)(u8g2->font_ref_ascent);
1007          //  tmp++;
1008          //  return tmp;
1009          //}
1010          
1011          //void u8g2_SetFontPosTop(u8g2_t *u8g2)
1012          //{
1013          //  u8g2->font_calc_vref = u8g2_font_calc_vref_top;
1014          //}
1015          
1016          //u8g2_uint_t u8g2_font_calc_vref_center(u8g2_t *u8g2)
1017          //{
1018          //  int8_t tmp;
1019          //  tmp = u8g2->font_ref_ascent;
1020          //  tmp -= u8g2->font_ref_descent;
1021          //  tmp /= 2;
1022          //  tmp += u8g2->font_ref_descent;  
1023          //  return tmp;
1024          //}
1025          
1026          //void u8g2_SetFontPosCenter(u8g2_t *u8g2)
1027          //{
1028          //  u8g2->font_calc_vref = u8g2_font_calc_vref_center;
1029          //}
1030          
1031          ///*===============================================*/
1032          
1033          //void u8g2_SetFont(u8g2_t *u8g2, const uint8_t  *font)
1034          //{
1035          //  if ( u8g2->font != font )
1036          //  {
C51 COMPILER V9.60.0.0   U8G2_FONT                                                         10/18/2024 17:39:02 PAGE 18  

1037          ////#ifdef  __unix__
1038          ////  u8g2->last_font_data = NULL;
1039          ////  u8g2->last_unicode = 0x0ffff;
1040          ////#endif 
1041          //    u8g2->font = font;
1042          //    u8g2_read_font_info(&(u8g2->font_info), font);
1043          //    u8g2_UpdateRefHeight(u8g2);
1044          //    /* u8g2_SetFontPosBaseline(u8g2); */ /* removed with issue 195 */
1045          //  }
1046          //}
1047          
1048          ///*===============================================*/
1049          
1050          //static uint8_t u8g2_is_all_valid(u8g2_t *u8g2, const char *str) U8G2_NOINLINE;
1051          //static uint8_t u8g2_is_all_valid(u8g2_t *u8g2, const char *str)
1052          //{
1053          //  uint16_t e;
1054          //  u8x8_utf8_init(u8g2_GetU8x8(u8g2));
1055          //  for(;;)
1056          //  {
1057          //    e = u8g2->u8x8.next_cb(u8g2_GetU8x8(u8g2), (uint8_t)*str);
1058          //    if ( e == 0x0ffff )
1059          //      break;
1060          //    str++;
1061          //    if ( e != 0x0fffe )
1062          //    {
1063          //      if ( u8g2_font_get_glyph_data(u8g2, e) == NULL )
1064          //  return 0;
1065          //    }
1066          //  }
1067          //  return 1;
1068          //}
1069          
1070          //uint8_t u8g2_IsAllValidUTF8(u8g2_t *u8g2, const char *str)
1071          //{
1072          //  u8g2->u8x8.next_cb = u8x8_utf8_next;
1073          //  return u8g2_is_all_valid(u8g2, str);
1074          //}
1075          
1076          
1077          ///* string calculation is stilll not 100% perfect as it addes the initial string offset to the overall si
             -ze */
1078          //static u8g2_uint_t u8g2_string_width(u8g2_t *u8g2, const char *str) U8G2_NOINLINE;
1079          //static u8g2_uint_t u8g2_string_width(u8g2_t *u8g2, const char *str)
1080          //{
1081          //  uint16_t e;
1082          //  u8g2_uint_t  w, dx;
1083          //#ifdef U8G2_BALANCED_STR_WIDTH_CALCULATION
1084          //  int8_t initial_x_offset = -64;
1085          //#endif 
1086          //  
1087          //  u8g2->font_decode.glyph_width = 0;
1088          //  u8x8_utf8_init(u8g2_GetU8x8(u8g2));
1089          //  
1090          //  /* reset the total width to zero, this will be expanded during calculation */
1091          //  w = 0;
1092          //  dx = 0;
1093          
1094          //  // printf("str=<%s>\n", str);
1095          //  
1096          //  for(;;)
1097          //  {
C51 COMPILER V9.60.0.0   U8G2_FONT                                                         10/18/2024 17:39:02 PAGE 19  

1098          //    e = u8g2->u8x8.next_cb(u8g2_GetU8x8(u8g2), (uint8_t)*str);
1099          //    if ( e == 0x0ffff )
1100          //      break;
1101          //    str++;
1102          //    if ( e != 0x0fffe )
1103          //    {
1104          //      dx = u8g2_GetGlyphWidth(u8g2, e);   /* delta x value of the glyph */
1105          //#ifdef U8G2_BALANCED_STR_WIDTH_CALCULATION
1106          //      if ( initial_x_offset == -64 )
1107          //        initial_x_offset = u8g2->glyph_x_offset;
1108          //#endif 
1109          //      //printf("'%c' x=%d dx=%d w=%d io=%d ", e, u8g2->glyph_x_offset, dx, u8g2->font_decode.glyph_width
             -, initial_x_offset);
1110          //      w += dx;
1111          //    }
1112          //  }
1113          //  //printf("\n");
1114          //  
1115          //  /* adjust the last glyph, check for issue #16: do not adjust if width is 0 */
1116          //  if ( u8g2->font_decode.glyph_width != 0 )
1117          //  {
1118          //    //printf("string width adjust dx=%d glyph_width=%d x-offset=%d\n", dx, u8g2->font_decode.glyph_width
             -, u8g2->glyph_x_offset);
1119          //    w -= dx;
1120          //    w += u8g2->font_decode.glyph_width;  /* the real pixel width of the glyph, sideeffect of GetGlyphWid
             -th */
1121          //    /* issue #46: we have to add the x offset also */
1122          //    w += u8g2->glyph_x_offset;  /* this value is set as a side effect of u8g2_GetGlyphWidth() */
1123          //#ifdef U8G2_BALANCED_STR_WIDTH_CALCULATION
1124          //    /* https://github.com/olikraus/u8g2/issues/1561 */
1125          //    if ( initial_x_offset > 0 )
1126          //      w+=initial_x_offset;
1127          //#endif 
1128          //  }
1129          //  // printf("w=%d \n", w);
1130          //  
1131          //  return w;  
1132          //}
1133          
1134          //static void u8g2_GetGlyphHorizontalProperties(u8g2_t *u8g2, uint16_t requested_encoding, uint8_t *w, int
             -8_t *ox, int8_t *dx)
1135          //{
1136          //  const uint8_t *glyph_data = u8g2_font_get_glyph_data(u8g2, requested_encoding);
1137          //  if ( glyph_data == NULL )
1138          //    return; 
1139          //  
1140          //  u8g2_font_setup_decode(u8g2, glyph_data);
1141          //  *w = u8g2->font_decode.glyph_width;
1142          //  *ox =  u8g2_font_decode_get_signed_bits(&(u8g2->font_decode), u8g2->font_info.bits_per_char_x);
1143          //  u8g2_font_decode_get_signed_bits(&(u8g2->font_decode), u8g2->font_info.bits_per_char_y);
1144          //  *dx = u8g2_font_decode_get_signed_bits(&(u8g2->font_decode), u8g2->font_info.bits_per_delta_x);
1145          //}
1146          
1147          ///* u8g compatible GetStrX function */
1148          //int8_t u8g2_GetStrX(u8g2_t *u8g2, const char *s)
1149          //{
1150          //  uint8_t w;
1151          //  int8_t dx;
1152          //  int8_t ox = 0;
1153          //  u8g2_GetGlyphHorizontalProperties(u8g2, *s, &w, &ox, &dx);
1154          //  return ox;
1155          //}
C51 COMPILER V9.60.0.0   U8G2_FONT                                                         10/18/2024 17:39:02 PAGE 20  

1156          
1157          
1158          ///*
1159          //Warning: This function needs to be fixed. I think it was taken over from u8glib, but not fixed as of now
             - 
1160          //The main difference for this procedure compared to the normal get width, should be, that the initial
1161          //offset is removed
1162          
1163          //Idea: for the user interface it probably would be better to add the xoffset of the first char to the end
             -, so that the overall word looks better.
1164          //Maybe then the procedure should be called differently, maybe balanced width instead of exact width
1165          
1166          //u8g2_calculate_exact_string_width is now OBSOLETE, instead the above str width calculation has been upda
             -ted:
1167          //https://github.com/olikraus/u8g2/issues/1561
1168          //*/
1169          //#ifdef OBSOLETE
1170          //static u8g2_uint_t u8g2_calculate_exact_string_width(u8g2_t *u8g2, const char *str)
1171          //{
1172          //  const char *s = str;
1173          //  uint16_t enc;
1174          //  u8g2_uint_t  w;
1175          //  uint8_t cnt;
1176          //  uint8_t gw; 
1177          //  int8_t ox, dx;
1178          //  
1179          //  /* reset the total minimal width to zero, this will be expanded during calculation */
1180          //  w = 0;
1181          //    
1182          //  
1183          //  /* check for empty string, width is already 0 */
1184          //  cnt = 0;
1185          //  
1186          //  for(;;)
1187          //  {
1188          //    enc = u8g2->u8x8.next_cb(u8g2_GetU8x8(u8g2), (uint8_t)*s);
1189          //    if ( enc == 0x0ffff )
1190          //      break;    
1191          //    s++;
1192          //    if ( enc != 0x0fffe )
1193          //    {
1194          //      if ( cnt == 0 )
1195          //      {
1196          //        /* get glyph properties of the first char */
1197          //        u8g2_GetGlyphHorizontalProperties(u8g2, enc, &gw, &ox, &dx);  
1198          //      }        
1199          //      cnt++;
1200          //      if ( cnt > 2 )
1201          //        break;
1202          //    }
1203          //  }
1204          //  
1205          //  if ( cnt == 0 )
1206          //    return 0;
1207          //   
1208          //  if ( cnt == 1 )
1209          //     return gw;
1210          
1211          //  /* strlen(s) == 1:       width = width(s[0]) */
1212          //  /* strlen(s) == 2:       width = - offx(s[0]) + deltax(s[0]) + offx(s[1]) + width(s[1]) */
1213          //  /* strlen(s) == 3:       width = - offx(s[0]) + deltax(s[0]) + deltax(s[1]) + offx(s[2]) + width(s[2])
             - */
C51 COMPILER V9.60.0.0   U8G2_FONT                                                         10/18/2024 17:39:02 PAGE 21  

1214          //  
1215          //  /* assume that the string has size 2 or more, than start with negative offset-x */
1216          //  /* for string with size 1, this will be nullified after the loop */
1217          //  w = -ox;  
1218          //  for(;;)
1219          //  {
1220          //    enc = u8g2->u8x8.next_cb(u8g2_GetU8x8(u8g2), (uint8_t)*str);
1221          //    if ( enc== 0x0ffff )
1222          //      break;
1223          //    str++;
1224          //    if ( enc != 0x0fffe )
1225          //    {
1226          //      u8g2_GetGlyphHorizontalProperties(u8g2, enc, &gw, &ox, &dx);        
1227          //      /* if there are still more characters, add the delta to the next glyph */
1228          //      w += dx;    
1229          //    }
1230          //  }
1231          //  
1232          //  /* finally calculate the width of the last char */
1233          //  /* here is another exception, if the last char is a blank, use the dx value instead */
1234          //  if ( gw != 0 )
1235          //  {
1236          //    w -= dx;    /* remove the last dx */
1237          //    /* if g was not updated in the for loop (strlen() == 1), then the initial offset x gets removed */
1238          //    w += gw;
1239          //    w += ox;
1240          //  }
1241          //  else
1242          //  {
1243          //    //w += dx;
1244          //  }
1245          //  
1246          //  
1247          //  return w;
1248          //  
1249          //}
1250          //#endif
1251          
1252          
1253          
1254          
1255          
1256          //u8g2_uint_t u8g2_GetStrWidth(u8g2_t *u8g2, const char *s)
1257          //{
1258          //  u8g2->u8x8.next_cb = u8x8_ascii_next;
1259          //  return u8g2_string_width(u8g2, s);
1260          //}
1261          
1262          ///* OBSOLETE
1263          //u8g2_uint_t u8g2_GetExactStrWidth(u8g2_t *u8g2, const char *s)
1264          //{
1265          //  u8g2->u8x8.next_cb = u8x8_ascii_next;
1266          //  return u8g2_calculate_exact_string_width(u8g2, s);
1267          //}
1268          //*/
1269          
1270          ///*
1271          //source: https://en.wikipedia.org/wiki/UTF-8
1272          //Bits  from    to      bytes Byte 1    Byte 2    Byte 3    Byte 4    Byte 5    Byte 6
1273          //  7   U+0000    U+007F    1     0xxxxxxx
1274          //11  U+0080    U+07FF    2     110xxxxx  10xxxxxx
1275          //16  U+0800    U+FFFF    3     1110xxxx  10xxxxxx  10xxxxxx
C51 COMPILER V9.60.0.0   U8G2_FONT                                                         10/18/2024 17:39:02 PAGE 22  

1276          //21  U+10000   U+1FFFFF  4     11110xxx  10xxxxxx  10xxxxxx  10xxxxxx
1277          //26  U+200000  U+3FFFFFF   5     111110xx  10xxxxxx  10xxxxxx  10xxxxxx  10xxxxxx
1278          //31  U+4000000   U+7FFFFFFF  6     1111110x  10xxxxxx  10xxxxxx  10xxxxxx  10xxxxxx  10xxxxxx  
1279          //*/
1280          //u8g2_uint_t u8g2_GetUTF8Width(u8g2_t *u8g2, const char *str)
1281          //{
1282          //  u8g2->u8x8.next_cb = u8x8_utf8_next;
1283          //  return u8g2_string_width(u8g2, str);
1284          //}
1285          
1286          
1287          
1288          //void u8g2_SetFontDirection(u8g2_t *u8g2, uint8_t dir)
1289          //{
1290          //#ifdef U8G2_WITH_FONT_ROTATION  
1291          //  u8g2->font_decode.dir = dir;
1292          //#endif
1293          //}
1294          
1295          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   ----    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
